package com.wilsoncys.compi1.java.model.analisis;

//importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;

import com.wilsoncys.compi1.java.model.asbtracto.Instruction;
import com.wilsoncys.compi1.java.model.programa.*;
 
import com.wilsoncys.compi1.java.model.excepciones.Errores;

import com.wilsoncys.compi1.java.model.simbolo.*;
import com.wilsoncys.compi1.java.model.instrucciones.*;
import com.wilsoncys.compi1.java.model.poo.*;
import com.wilsoncys.compi1.java.model.expresiones.*;

import com.wilsoncys.compi1.java.model.expresiones.Aritmeticas.*;
import com.wilsoncys.compi1.java.model.expresiones.Enums.*;
import com.wilsoncys.compi1.java.model.programa.*;
import com.wilsoncys.compi1.java.model.programa.expresiones.*;
import com.wilsoncys.compi1.java.model.programa.instrucciones.*;
import com.wilsoncys.compi1.java.model.instruccionesPas.*;
import com.wilsoncys.compi1.java.model.expresionesPas.*;


import java.util.HashMap;
 

// parser
parser code
{:
    private String currentAmbit;

    scanner s;
    parser(scanner s){this.s = s;}

    public LinkedList<Errores> listaErrores = new LinkedList<>();
    
    public void syntax_error(Symbol s){
        listaErrores.add(new Errores("SINTACTICO RECUPERABLE",
                        "No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        listaErrores.add(new Errores("SINTACTICO NO RECUPERABLE",
                        "No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

    // public void syntax_error(Symbol s){
    //     System.out.println("Error Sintactico en la linea " +
    //     (s.left) + " y columna " + (s.right) +
    //     ". No se esperaba el componente: " + (s.value) + ".");
    // }

    // public void unrecovered_syntax_error (Symbol s){
    //     System.out.println("Error Sintactico no recuperable en la linea" +
    //     (s.left) + " y columna " + (s.right) +
    //     ". No se esperaba el componente: " + (s.value) + ".");
    // }


:}

action code
{:
:}

//terminales
                        //JAVA                  
terminal String CADENA, BOOL, CHARAC, ENTERO, DECIMAL, ID;
terminal PLUS, MINUS, TIMES, DIVIDED, RAISED, MOD;
terminal GREATER, LESS, G_EQUALS, L_EQUALS, EQUALS, DIFFERENT;
terminal ASSIGNMENT;
terminal DO, IF, ELSE, FOR, BREAK, SWITCH, WHILE, CONTINUE, DEFAULT;

terminal OR, AND, NOT;
terminal UNEGATIVE, UMINUS;
terminal PLUSPLUS, MINUSMINUS;
terminal NULL;

terminal PRINT, INT, DOUBLE, BOOLEAN, CHAR, STRING, VOID;
terminal PAR_OP, PAR_CL, K_OP, K_CL, SEMIC, POINTS, BRACK_L, BRACK_R;
terminal VAR, CONST, COLON,  NEW, DOT;
terminal RETURN;
terminal PROTECTED, PRIVATE, PUBLIC;
terminal EXTENDS, THIS, MAIN, CLASS, PRINTLN;
terminal INP_C,INP_INT, INP_F;


//#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$
                        // PASCAL
//#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$

 
terminal PROCEDURE, REPEAT, THEN, TO;
terminal ARRAY, BEGIN, UNTIL;
terminal END, READLN, OF, REAL, FUNCTION;
 
 

//#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$
                        // CCCCC
//#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$

terminal PASCAL, JAVA, CASE, GETCH;
terminal PASCALUNO, JAVAUNO, PASCALSIMP, JAVATODO, INCLUDE;
terminal MASK_D, MASK_C, MASK_F, MASK_S, SCAN, ANDSIMPLE, CLRSCR;






//no terminales
nonterminal LinkedList<Instruction> INICIO, InstructionES;
nonterminal Instruction Instruction, EXPRESION;
nonterminal Instruction globalDec, asignacion, increaseDecrease;
nonterminal Boolean mutabilidad;
// nonterminal Relational_LogicalOperations operador, logical;
nonterminal Tipo typeVar;
nonterminal Instruction print, while, do, for, match;
nonterminal Instruction if, simpleIf, elsees, declaraAsigna, updateVarFor;
nonterminal LinkedList<Instruction> cierreElse, valoresVectorAlone;
nonterminal LinkedList<CaseMatch>  listCases;
nonterminal CaseMatch case;
nonterminal Instruction continue, break,  methodd;
nonterminal Instruction declaracionEstructuraD;
nonterminal LinkedList<LinkedList<Instruction>>  valoresVector2D;
nonterminal LinkedList<HashMap>  parametersFuncts;
nonterminal LinkedList<Instruction>  callsParameters;
nonterminal Instruction call, returnn, callEXP;
nonterminal modPriv;
nonterminal Call call2, callEXP2;
nonterminal Instruction gIns, declaracion;
nonterminal Instruction assig_to_acces;
nonterminal LinkedList<Instruction> gInstructionss, insClass, methodIns;
nonterminal LinkedList<Instruction> paramss, claass, instructionsIF;
nonterminal Instruction Oneclaass, constructor, instructionIF;


nonterminal LinkedList<Instruction> pascal, 
         java_C, instructionsC;

//CPRINCIPAL
nonterminal Instruction cPrincipal, decConstC, decVarsC, mainC;
nonterminal Instruction EXPRESIONCC, printf, scanf, asignacionC,
        whileC, forC, DOC, ifC, switchC, callC
        ,decObjetos, elseesC, simpleIfC
        , declaraAsignaC, updateVarForC
        , callExpC, inSwC, insC;
nonterminal Instruction pascalCode;

nonterminal LinkedList<Instruction>  callsParametersC
        ,instancesC, cierreElseC, paramssC, insSwC
        , declaracionC; 
nonterminal Instruction decVecC;
nonterminal LinkedList<CaseMatchC>  listCasesC;
nonterminal CaseMatchC  caseC;
nonterminal Tipo typeC;


nonterminal Includes includes;
nonterminal String includeJ, includeP;
nonterminal LinkedList<String> varsPrintf;
// nonterminal LinkedList<Instruction> pascalCode;

 //#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$
                        // PASCAL
//#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$
 
//no terminales
nonterminal LinkedList<Instruction> initiate, InstructionESPas;
nonterminal LinkedList<Instruction>  declaracionPas;
nonterminal  Instruction  InstructionPas, expPas;
// nonterminal  Instruction printPas, callPas;
nonterminal  Instruction printPas;
nonterminal  Instruction asignacionPas, declaraArr;
nonterminal Tipo typeVarPas;
nonterminal Instruction whilePas, forPas, repeatPas, InstructionSinSemi, inputPas;
nonterminal Instruction  ifPas;
nonterminal Instruction continuePas, breakPas;
nonterminal LinkedList<HashMap>  parametersFunctsPas, paramFunction;
// nonterminal LinkedList<Instruction>  callsParametersPasPas;
nonterminal LinkedList<Instruction> expresionessPas;
nonterminal LinkedList<Instruction> insIfNoSemi, bloqueIns;
nonterminal LinkedList<String> ids;
nonterminal LinkedList<OneCasePas>  listCasesPas;
nonterminal OneCasePas unCase;
nonterminal StatementCasePas casePas;
nonterminal Instruction unaDeclaracion, AssignmentVectoresPas;
nonterminal Instruction function;
nonterminal LinkedList<Instruction>  variablesFunct, funtionssPas,  optionalLocalDc, bodyFunction; 
// nonterminal HashMap paramFunction;
 



precedence left ID;     



precedence left OR;
precedence left AND;
 
precedence right UNEGATIVE;


precedence left EQUALS, DIFFERENT, LESS, L_EQUALS, GREATER, G_EQUALS;

 
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDED, MOD;
precedence nonassoc RAISED;

// precedence left ID;

precedence right UMINUS;
precedence left ELSE;


start with INICIO;

 
// INICIO ::= claass:a      {:   RESULT = a; :}
INICIO::= pascal:a      {:   RESULT = a; :}
;

pascal::=  pascalCode:p java_C:c_J {: RESULT = new LinkedList<>();
        if(p!=null){
                 
                RESULT.add(p);
        }
        if(c_J!=null){
                RESULT.addAll(c_J);
        }
                                :}
|java_C:c {: RESULT = c; :}
;


java_C::= claass:j cPrincipal:c {: 
        RESULT = new LinkedList<>(); 
        if(j!=null){
        ClasesJava cl = new ClasesJava(j, jleft, jright);
                RESULT.add(cl);
        }
        if(c!=null){
                 RESULT.add(c); 
        } 
                 :}
| cPrincipal:c {: RESULT = new LinkedList<>(); 
        if(c!=null){
                RESULT.add(c); 
        }:}
|error {: RESULT = new LinkedList<>(); :} 
;

 

//GRAMATICA PROGRAMA PRINCIPAL
cPrincipal::= includes:in declaracionC:ins mainC:main  
        {: RESULT = new Programa(in, ins, main, inleft, inright); :}
| {: RESULT = null; :}
;
 
 



includes::= includeP:in  includes:ins
          {: RESULT = ins;
           RESULT.addSubPPascal(in); :}
|includeJ:in  includes:ins
         {: RESULT = ins;
         RESULT.addClaseJava(in); :}
|        {: RESULT = new Includes(); :}
;
includeP::= INCLUDE PASCALUNO:id {: RESULT = id.toString(); :} 
        |INCLUDE PASCALSIMP:id  {: RESULT = id.toString(); :} 
;
includeJ::= INCLUDE JAVAUNO:id {: RESULT = id.toString(); :} 
        |INCLUDE JAVATODO:id  {: RESULT = id.toString(); :} 
;



decConstC::= CONST typeC:t ID:id ASSIGNMENT EXPRESIONCC:exp SEMIC
  {: RESULT = new StatementC(id, exp, t, idleft, idright, true); :}    
;
 
decVarsC::= typeC:t ID:id ASSIGNMENT EXPRESIONCC:exp SEMIC
  {: RESULT = new StatementC(id, exp, t, idleft, idright, false); :}    
        | typeC:t ID:id SEMIC
  {: RESULT = new StatementC(id, t, idleft, idright, false); :}
;

//vectores
decVecC::=   typeC:t ID:id    BRACK_L  EXPRESIONCC:e1 BRACK_R  SEMIC
                         {: RESULT = new VectorsStatementC(false, id, e1,  t,  tleft, tright); :}
        | typeC:t ID:id  BRACK_L EXPRESIONCC:e1 BRACK_R BRACK_L EXPRESIONCC:e2 BRACK_R SEMIC
                         {: RESULT = new VectorsStatementC(false, id, e1, e2, t, tleft, tright); :}
        ;





mainC::= VOID MAIN:a PAR_OP PAR_CL K_OP  instructionsC:ins  K_CL
        {:RESULT = new MainnC("MAIN", ins, aleft, aright); :}
;


declaracionC::= declaracionC:decs decConstC:dec 
        {: RESULT = decs; RESULT.add(dec);  :}
| declaracionC:decs decVarsC:dec 
        {: RESULT = decs; RESULT.add(dec);  :}
| declaracionC:decs decVecC:dec 
        {: RESULT = decs; RESULT.add(dec);  :}
| declaracionC:decs decObjetos:dec 
        {: RESULT = decs; RESULT.add(dec);  :}
| {:RESULT = new LinkedList<>(); :}
;

instructionsC::=  instructionsC:ins insC:in {: RESULT = ins; RESULT.add(in); :}
                | {: RESULT = new LinkedList<>(); :}
;


typeC::= INT {: RESULT = new Tipo(tipoDato.ENTERO); :}
|CHAR   {: RESULT = new Tipo(tipoDato.CARACTER); :}
|DOUBLE  {: RESULT = new Tipo(tipoDato.DECIMAL); :}
|STRING  {: RESULT = new Tipo(tipoDato.CADENA); :}
;
 

  

printf::= PRINT:a PAR_OP CADENA:w PAR_CL SEMIC
                {:RESULT = new PrintsC(w, wleft, wright);  :}
        | PRINT:a PAR_OP CADENA:c varsPrintf:ids PAR_CL SEMIC {: RESULT = new PrintsC(c, ids, aleft, aright); :}
;
//scanf   printf("Integer: %d, Character: %c, Float: %.2f", 10, 'B', 2.718);
varsPrintf::= COLON ID:id {: RESULT = new LinkedList<>();  RESULT.add(id);   :}
        | varsPrintf:ids  COLON ID:id {: RESULT = ids; RESULT.add(id);  :}
;


scanf::= SCAN:a PAR_OP MASK_D COLON ANDSIMPLE ID:id PAR_CL SEMIC 
                {:RESULT = new ScanfC(id, new Tipo(tipoDato.ENTERO), aleft, aright ); ;:}
        |SCAN:a PAR_OP MASK_C COLON ANDSIMPLE ID:id PAR_CL SEMIC
                {:RESULT = new ScanfC(id, new Tipo(tipoDato.CARACTER), aleft, aright ); ;:}
        |SCAN:a PAR_OP MASK_F COLON ANDSIMPLE ID:id PAR_CL SEMIC
                {:RESULT = new ScanfC(id, new Tipo(tipoDato.DECIMAL), aleft, aright ); ;:}
        |SCAN:a PAR_OP MASK_S COLON ANDSIMPLE ID:id PAR_CL SEMIC
                {:RESULT = new ScanfC(id, new Tipo(tipoDato.CADENA), aleft, aright ); ;:}
;

asignacionC::= ID:id ASSIGNMENT EXPRESIONCC:exp SEMIC
        {: RESULT = new AssignmenttC(id, exp, idleft, idright); :}
;


insC::= PRINT PAR_OP PAR_CL SEMIC
|CLRSCR:a PAR_OP  PAR_CL SEMIC {: RESULT = new Clr(aleft, aright); :}
|GETCH:a PAR_OP PAR_CL SEMIC {:RESULT = new getchC(true, aleft, aright); :}
| scanf:w {:RESULT = w; :}
| asignacionC:c {: RESULT = c; :}
| printf:c {: RESULT = c; :}
|whileC:w {: RESULT = w; :}
|forC:w {: RESULT = w;  :}
|DOC:w {: RESULT = w;  :}
|BREAK SEMIC
|CONTINUE SEMIC
|ifC:w {: RESULT = w; :}
|switchC:w {: RESULT = w; :}
|callC:c {: RESULT = c; :}
| error SEMIC {:  :}
;


inSwC::= PRINT PAR_OP PAR_CL SEMIC
|CLRSCR PAR_OP  PAR_CL SEMIC
|GETCH:a PAR_OP PAR_CL SEMIC {:RESULT = new getchC(true, aleft, aright); :}
| scanf
| asignacionC:w {: RESULT = w; :} 
| printf:w {: RESULT = w; :}
|whileC:w {: RESULT = w; :}
|forC:w {: RESULT = w;  :}
|DOC:w {: RESULT = w;  :}
|ifC:w {: RESULT = w;  :}
|switchC:w   {: RESULT = w; :}
|callC:w {: RESULT = w; :}
// |error SEMIC
;
 
insSwC::=  insSwC:ins inSwC:in
         {: RESULT=ins;  RESULT.add(in); :}
| {: RESULT = new LinkedList<>(); :}
;



//OBJETOS (instanciacion)
decObjetos::= JAVA DOT ID:cl instancesC:ins 
        {:
            RESULT = new ReferenceC(cl,ins, clleft, clright);    
        :}
 ;


instancesC::= ID:id PAR_OP paramssC:p PAR_CL COLON  instancesC:ins
        {: RESULT = ins;
        InstanceJava cl = new InstanceJava(id, p, idleft, idright); 
        RESULT.add(cl);

        :}
        | ID:id PAR_OP paramssC:p PAR_CL SEMIC
        {: RESULT = new LinkedList<>();
          InstanceJava cl = new InstanceJava(id, p, idleft, idright); 
          RESULT.add(cl);
        :}
;


whileC::= WHILE:a PAR_OP EXPRESIONCC:exp PAR_CL
        K_OP  instructionsC:ins K_CL
        {: RESULT = new CiclicaWhileC(exp, ins, false, aleft, aright); :}
;


DOC::= DO:a K_OP  instructionsC:ins K_CL
        WHILE PAR_OP EXPRESIONCC:exp PAR_CL SEMIC
        {: RESULT = new CiclicaWhileC(exp, ins, false, aleft, aright); :}
;
 
ifC::=   IF PAR_OP EXPRESIONCC:exp PAR_CL  K_OP instructionsC:ins K_CL ELSE  ifC:elif
         {: RESULT = new IFC(exp, ins, elif, expleft, expright);    :}
        |elseesC:w {: RESULT = w; :}
        |simpleIfC:w {: RESULT = w; :}
; 

cierreElseC::= ELSE K_OP instructionsC:ins {: RESULT = ins;  :} K_CL 
;

simpleIfC::=  IF PAR_OP EXPRESIONCC:a PAR_CL  K_OP instructionsC:ins K_CL   
                        {: RESULT = new IFC(a, ins, aleft, aright); :}
; 

//     public IF(Instruction expression, LinkedList<Instruction> instructionss, LinkedList<Instruction> instructionsElse, int linea, int col) {
elseesC::=  IF PAR_OP EXPRESIONCC:exp PAR_CL  K_OP instructionsC:ins K_CL cierreElseC:insEls   
                {: RESULT = new IFC(exp, ins, insEls, expleft, expright); :}
;


forC::= FOR PAR_OP asignacionC:a  EXPRESIONCC:b SEMIC     updateVarForC:c PAR_CL K_OP  instructionsC:ins K_CL
                {: RESULT = new CiclicaForC(a, b, c, ins, aleft, aright); :}
;


//     public CiclicaFor(Instruction asignacion, Instruction condicion, Instruction actualizacion, LinkedList<Instruction> instrucciones, int linea, int col) {
updateVarForC::=  ID:id PLUSPLUS  {: RESULT = new IncreaseDecreaseC(id, true, idleft, idright); :}
        |ID:id  MINUSMINUS  {: RESULT = new IncreaseDecreaseC(id, false, idleft, idright); :}
        |ID:id ASSIGNMENT EXPRESIONCC:exp {:  RESULT = new AssignmenttC(id, exp, idleft, idright);  :}
        ;
        
// //esto es para los ciclos 
// declaraAsignaC::= asignacionC 
//                 | typeC ID ASSIGNMENT EXPRESIONCC SEMIC
// ;


switchC::= SWITCH PAR_OP EXPRESIONCC:exp PAR_CL K_OP  listCasesC:cazzoz K_CL
                 {: RESULT = new MatchC(exp, cazzoz, expleft, expright); :}
;

listCasesC::=  listCasesC:b  caseC:a {: RESULT = b; RESULT.add(a); :}
        |   {:  RESULT = new LinkedList<>();    :}
        ;


caseC::=  CASE  EXPRESIONCC:a POINTS insSwC:ins BREAK SEMIC
        {: RESULT = new CaseMatchC(a, ins, false, aleft, aright); :}
        | DEFAULT:a  POINTS insSwC:ins BREAK SEMIC
        {: RESULT = new CaseMatchC(null, ins, true, aleft, aright); :}
;

callsParametersC ::= callsParametersC:a COLON EXPRESIONCC:e    {:  RESULT = a;
                                                    RESULT.add(e);
                                                :}
            | EXPRESIONCC:a                       {:  RESULT = new LinkedList<Instruction>(); 
                                                    RESULT.add(a);
                                                :}
            
;
paramssC::= callsParametersC:c {:RESULT = c; :}
        | {:RESULT = new LinkedList<>(); :}
;


callC::= PASCAL DOT ID:id PAR_OP paramssC:p PAR_CL SEMIC
        {: RESULT = new call_to_pas(id, p, idleft, idright ); :}
        | JAVA DOT ID:id DOT ID:id1 PAR_OP paramssC:p PAR_CL SEMIC
        {: RESULT = new call_to_java(id, id1, p, idleft, idright ); :}
;


callExpC::= PASCAL DOT ID:id PAR_OP paramssC:p PAR_CL 
        {: RESULT = new call_to_pas(id, p, idleft, idright ); :}
        | JAVA DOT ID:id DOT ID:id1 PAR_OP paramssC:p PAR_CL  
                {: RESULT = new call_to_java(id, id1, p, idleft, idright ); :}
;


  



// PASCAL.nombre_funcion(par√°metro);
EXPRESIONCC::= MINUS EXPRESIONCC:a             {:   RESULT = new Negacion(a, OperadoresAritmeticos.NEGACION, aleft, aright);   :} %prec UMINUS
            | NOT EXPRESIONCC:a  {:   RESULT = new LogicalOperations(a, Relational_LogicalOperations.NOT, aleft, aright);   :}              %prec UNEGATIVE
            | EXPRESIONCC:a PLUS EXPRESIONCC:b   {:   RESULT = new Suma(a, b, OperadoresAritmeticos.SUMA, aleft, aright);   :}
            | EXPRESIONCC:a MINUS EXPRESIONCC:b   {:   RESULT = new Resta(a, b, OperadoresAritmeticos.RESTA, aleft, aright);   :}
            | EXPRESIONCC:a DIVIDED EXPRESIONCC:b   {:   RESULT = new Division(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);   :}
            | EXPRESIONCC:a TIMES EXPRESIONCC:b   {:   RESULT = new Multiplicacion(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);   :}
            | EXPRESIONCC:a MOD EXPRESIONCC:b   {:   RESULT = new Modulee(a, b, OperadoresAritmeticos.MODULO, aleft, aright);   :}
            | EXPRESIONCC:a RAISED EXPRESIONCC:b   {:   RESULT = new Raised(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright);   :}
            
            | EXPRESIONCC:a EQUALS:op EXPRESIONCC:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.IGUALA, aleft, aright);   :}
            | EXPRESIONCC:a DIFFERENT:op EXPRESIONCC:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.DIFERENTEQUE, aleft, aright);   :}
            | EXPRESIONCC:a LESS:op EXPRESIONCC:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MENOR, aleft, aright);   :}
            | EXPRESIONCC:a L_EQUALS:op EXPRESIONCC:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MENOR_IGUAL, aleft, aright);   :}
            | EXPRESIONCC:a GREATER:op EXPRESIONCC:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MAYOR, aleft, aright);   :}
            | EXPRESIONCC:a G_EQUALS:op EXPRESIONCC:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MAYOR_IGUAL, aleft, aright);   :}
            
            | EXPRESIONCC:a AND:log EXPRESIONCC:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.AND, aleft, aright);   :}
            | EXPRESIONCC:a OR:log EXPRESIONCC:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.OR, aleft, aright);   :}
            | PAR_OP EXPRESIONCC:a PAR_CL    {:   RESULT = a;   :}  

            | ENTERO:a      {:   RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright );   :}
            | CHARAC:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright );   :}
//float
            | DECIMAL:a     {:   RESULT = new Nativo(new Double(a), new Tipo(tipoDato.DECIMAL), aleft, aright );   :}   
            | CADENA:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright );   :}
            
            | ID:a      {:   RESULT = new AccessC(a, aleft, aright);   :}
//arrs
            | ID:a BRACK_L EXPRESIONCC:indx BRACK_R      {:   RESULT = new AccesVector(a, indx, aleft, aright);   :}
            | ID:a BRACK_L EXPRESIONCC:indx1 BRACK_R    BRACK_L  EXPRESIONCC:indx2 BRACK_R 
             {:   RESULT = new AccesVector(a, indx1, indx2, aleft, aright);   :}


            | GETCH:a PAR_OP PAR_CL {:RESULT = new getchC(false,aleft, aright); :}   
            | callExpC:c {: RESULT = c; :} 
;



 






































//GRAMATICA  JAVA
claass::= Oneclaass:c {: RESULT = new LinkedList<>(); RESULT.add(c); :} 
        | claass:cls Oneclaass:c  {: RESULT = cls; RESULT.add(c); :}
;



InstructionES::= InstructionES:a Instruction:b     {: RESULT = a; RESULT.add(b); :}
                |                          {: RESULT = new LinkedList<>();  :}
                // | Instruction:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;
// methodIns::=InstructionES:ins {: RESULT = ins; :}
//         | {:RESULT = new LinkedList<>(); :}
// ;


constructor::=  ID:id  PAR_OP parametersFuncts:p PAR_CL K_OP InstructionES:ins K_CL 
                        {: RESULT = new Mainn(id, p, ins, idleft, idright );  :}
        | ID:id  PAR_OP PAR_CL K_OP InstructionES:ins K_CL 
                        {: RESULT = new Mainn(id, new LinkedList<HashMap>(), ins, idleft, idright );  :}
        | modPriv ID:id PAR_OP parametersFuncts:p PAR_CL  K_OP InstructionES:ins K_CL 
                        {: RESULT = new Mainn(id, p, ins, idleft, idright );  :}
        | modPriv ID:id PAR_OP PAR_CL  K_OP InstructionES:ins K_CL 
                        {: RESULT = new Mainn(id, new LinkedList<HashMap>(), ins, idleft, idright );  :}
;

modPriv::= PUBLIC
        |PROTECTED
        |PRIVATE
;

 

Oneclaass::=  CLASS ID K_OP gInstructionss K_CL 
        | PUBLIC CLASS ID:id K_OP insClass:ins K_CL 
                {: RESULT = new Classs(id, ins, idleft, idright); :}
        |  CLASS ID EXTENDS ID K_OP gInstructionss K_CL         
        | PUBLIC CLASS ID EXTENDS ID K_OP gInstructionss K_CL         
;

insClass::= gInstructionss:ins {: RESULT = ins;:}
        | {:RESULT = new LinkedList<>(); :}
;

gInstructionss::= gIns:in {:RESULT = new LinkedList<>(); RESULT.add(in);:}
        | gInstructionss:ins gIns:in  {: RESULT = ins; RESULT.add(in); :}
        // | {: RESULT = null:}
;

gIns::= methodd:m {:RESULT = m; :}
        |globalDec:g {:RESULT = g; :}
;


Instruction::= declaracion:w {: RESULT = w; :}
        | asignacion:w {: RESULT = w; :}
        | print:w {: RESULT = w ; :}
        | if:w {: RESULT = w; :}
        | increaseDecrease:w {: RESULT = w; :}
        | for:w {: RESULT = w; :}
        | while:w {: RESULT =w;:}
        | do:w {: RESULT = w; :}
        | match:w {: RESULT = w; :}
        // | break:w {: RESULT = w; :}
        | returnn:w {: RESULT = w; :}
        | continue:w {: RESULT = w;:}
        | declaracionEstructuraD:w {: RESULT = w; :}
        // | methodd:w {: RESULT = w; :}
        | call:w {: RESULT = w; :} 
        | error SEMIC
        | error
        ;


EXPRESION::= MINUS EXPRESION:a             {:   RESULT = new Negacion(a, OperadoresAritmeticos.NEGACION, aleft, aright);   :} %prec UMINUS
            | NOT EXPRESION:a  {:   RESULT = new LogicalOperations(a, Relational_LogicalOperations.NOT, aleft, aright);   :}              %prec UNEGATIVE
            | EXPRESION:a PLUS EXPRESION:b   {:   RESULT = new Suma(a, b, OperadoresAritmeticos.SUMA, aleft, aright);   :}
            | EXPRESION:a MINUS EXPRESION:b   {:   RESULT = new Resta(a, b, OperadoresAritmeticos.RESTA, aleft, aright);   :}
            | EXPRESION:a DIVIDED EXPRESION:b   {:   RESULT = new Division(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);   :}
            | EXPRESION:a TIMES EXPRESION:b   {:   RESULT = new Multiplicacion(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);   :}
            | EXPRESION:a MOD EXPRESION:b   {:   RESULT = new Modulee(a, b, OperadoresAritmeticos.MODULO, aleft, aright);   :}
            | EXPRESION:a RAISED EXPRESION:b   {:   RESULT = new Raised(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright);   :}
            
            | EXPRESION:a EQUALS:op EXPRESION:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.IGUALA, aleft, aright);   :}
            | EXPRESION:a DIFFERENT:op EXPRESION:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.DIFERENTEQUE, aleft, aright);   :}
            | EXPRESION:a LESS:op EXPRESION:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MENOR, aleft, aright);   :}
            | EXPRESION:a L_EQUALS:op EXPRESION:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MENOR_IGUAL, aleft, aright);   :}
            | EXPRESION:a GREATER:op EXPRESION:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MAYOR, aleft, aright);   :}
            | EXPRESION:a G_EQUALS:op EXPRESION:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MAYOR_IGUAL, aleft, aright);   :}
            
            | EXPRESION:a AND:log EXPRESION:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.AND, aleft, aright);   :}
            | EXPRESION:a OR:log EXPRESION:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.OR, aleft, aright);   :}
            | PAR_OP EXPRESION:a PAR_CL    {:   RESULT = a;   :}  
            | DECIMAL:a     {:   RESULT = new Nativo(new Double(a), new Tipo(tipoDato.DECIMAL), aleft, aright );   :}
            | CADENA:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright );   :}
            | CHARAC:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright );   :}
            | BOOL:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.BOOLEANO), aleft, aright );   :}
            | NULL:a      {:   RESULT = new Null(new Tipo(tipoDato.VOID), aleft, aright );   :}
            | ID:a      {:   RESULT = new Access(a, aleft, aright);   :}
            | ENTERO:a      {:   RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright );   :}
            | THIS DOT ID:a      {:   RESULT = new Access(a, true, aleft, aright);   :}

            | ID:a BRACK_L EXPRESION:indx BRACK_R      {:   RESULT = new AccesVector(a, indx, aleft, aright);   :}
            | ID:a BRACK_L EXPRESION:indx1 BRACK_R BRACK_L  EXPRESION:indx2 BRACK_R      {:   RESULT = new AccesVector(a, indx1, indx2, aleft, aright);   :}
            | callEXP:a {: RESULT = a; :}    
            | NEW ID:t  PAR_OP callsParameters:p PAR_CL     
                {:RESULT = new Reference(t, p, tleft, tright); :}
            | NEW ID:t  PAR_OP PAR_CL  
                {:RESULT = new Reference(t, new LinkedList<>(), tleft, tright); :}
        //     | ID:idStruct DOT ID:field {: RESULT = new Access(idStruct, field, idStructright, idStructleft); :} 
        //     | ID:idStruct DOT ID:field DOT ID:elseID {: RESULT = new Access(idStruct, field, elseID, idStructright, idStructleft); :} 
        //     | K_OP:a valuesStruct:valuess K_CL {: RESULT = new Structs(null, valuess, aleft, aright); :}
;
  

// public Method(String id, LinkedList<HashMap> parametros, LinkedList<Instruction> instrucciones, Tipo tipo, int linea, int col) {
methodd::= modPriv VOID:a ID:b PAR_OP parametersFuncts:p PAR_CL K_OP InstructionES:c K_CL    {:   RESULT= new Method(b, p, c, new Tipo(tipoDato.VOID), aleft, aright );   :}
|  modPriv VOID:a ID:b PAR_OP PAR_CL K_OP InstructionES:c K_CL             {:   RESULT= new Method(b, new LinkedList<HashMap>(), c, new Tipo(tipoDato.VOID), aleft, aright );   :}
|  modPriv typeVar:a ID:b PAR_OP parametersFuncts:p PAR_CL K_OP InstructionES:c K_CL    {:   RESULT= new Functionss(b, p, c, a, aleft, aright );   :}
|  modPriv typeVar:a ID:b PAR_OP PAR_CL K_OP InstructionES:c K_CL             {:   RESULT= new Functionss(b, new LinkedList<HashMap>(), c, a, aleft, aright );   :}   
|  VOID:a ID:b PAR_OP parametersFuncts:p PAR_CL K_OP InstructionES:c K_CL    {:   RESULT= new Method(b, p, c, new Tipo(tipoDato.VOID), aleft, aright );   :}
|   VOID:a ID:b PAR_OP PAR_CL K_OP InstructionES:c K_CL             {:   RESULT= new Method(b, new LinkedList<HashMap>(), c, new Tipo(tipoDato.VOID), aleft, aright );   :}
|   typeVar:a ID:b PAR_OP parametersFuncts:p PAR_CL K_OP InstructionES:c K_CL    {:   RESULT= new Functionss(b, p, c, a, aleft, aright );   :}
|   typeVar:a ID:b PAR_OP PAR_CL K_OP InstructionES:c K_CL             {:   RESULT= new Functionss(b, new LinkedList<HashMap>(), c, a, aleft, aright );   :}
        
      
      
// |  VOID:a MAIN:b PAR_OP parametersFuncts:p PAR_CL K_OP InstructionES:c K_CL    {:   RESULT= new Method("MAIN", p, c, new Tipo(tipoDato.VOID), aleft, aright );   :}
// |  VOID:a MAIN:b PAR_OP PAR_CL K_OP InstructionES:c K_CL    {:   RESULT= new Method("Main", new LinkedList<HashMap>(), c, new Tipo(tipoDato.VOID), aleft, aright );   :}
        | constructor:c {:RESULT = c; :}
;

parametersFuncts::= parametersFuncts:a COLON typeVar:b ID:id   {:  
                                            RESULT = a;
                                            var elseParam= new HashMap<String, Object>();
                                            elseParam.put("id", id);
                                            elseParam.put("tipo", b);
                                            RESULT.add(elseParam);
                                        :}
        | typeVar:a ID:id                  {:  RESULT = new LinkedList<HashMap>(); 
                                            var oneParam = new HashMap<String, Object>();
                                            oneParam.put("id",id);
                                            oneParam.put("tipo", a);
                                            RESULT.add(oneParam);
                                        :}
;

// callEXP::= ID:a PAR_OP callsParameters:params PAR_CL {: RESULT = new Call(a, params, aleft, aright); :}
//         | ID:a PAR_OP PAR_CL {: RESULT = new Call(a, new LinkedList<Instruction>(), aleft, aright); :}
// ; 

paramss::= callsParameters:c {:RESULT = c; :}
        | {:RESULT = new LinkedList<>(); :}
;



callEXP::= ID:id DOT callEXP2:call1   
        {: RESULT = new Call(id, call1, idleft, idright); :}
        | ID:a PAR_OP paramss PAR_CL  DOT callEXP2
        | ID:a PAR_OP paramss:p PAR_CL 
        {: RESULT = new Call(a, p, aleft, aright); :}
;
// getA() . call2
callEXP2::=  
// ID:a PAR_OP paramss PAR_CL DOT callEXP
           ID:a PAR_OP paramss PAR_CL DOT callEXP2
          | ID:a PAR_OP paramss:p PAR_CL 
        {:RESULT = new Call(a, p, aleft, aright); :}
          | ID:a DOT callEXP2  
          | ID:a  
;


call::= ID:id DOT call2:call1
        {: RESULT = new Call(id, call1, idleft, idright); :}
        | ID:a PAR_OP paramss:p PAR_CL DOT call2
        | ID:a PAR_OP paramss:p PAR_CL SEMIC 
        {:RESULT = new Call(a, p, aleft, aright); :}
;       
call2::= ID PAR_OP paramss:p PAR_CL DOT call
        |  ID DOT call
        | ID:a PAR_OP paramss:p PAR_CL SEMIC
        {:RESULT = new Call(a, p, aleft, aright); :}

;
 
 
 

callsParameters ::= callsParameters:a COLON EXPRESION:e    {:  RESULT = a;
                                                    RESULT.add(e);
                                                :}
            | EXPRESION:a                       {:  RESULT = new LinkedList<Instruction>(); 
                                                    RESULT.add(a);
                                                :}
            
;


 

instructionIF::= Instruction:ins {: RESULT = ins; :}
        | break:b {: RESULT = b; :}
;

instructionsIF::= instructionsIF:inss instructionIF:ins {:  RESULT = inss; RESULT.add(ins); :}
                | {:RESULT = new LinkedList(); :}
;



if::=   IF PAR_OP EXPRESION:exp PAR_CL  K_OP instructionsIF:ins K_CL ELSE  if:elif {: RESULT = new IF(exp, ins, elif, expleft, expright);    :}
        |elsees:w {: RESULT = w; :}
        |simpleIf:w {: RESULT = w; :}
; 

/*
for(var i:int=0; i<10; i++){
    println(i);
}*/
for::= FOR PAR_OP   declaraAsigna:a  EXPRESION:b SEMIC     updateVarFor:c PAR_CL K_OP InstructionES:ins K_CL
                {: RESULT = new CiclicaFor(a, b, c, ins, aleft, aright); :}
;

//     public CiclicaFor(Instruction asignacion, Instruction condicion, Instruction actualizacion, LinkedList<Instruction> instrucciones, int linea, int col) {
updateVarFor::=  ID:id PLUSPLUS  {: RESULT = new IncreaseDecrease(id, true, idleft, idright); :}
        |ID:id  MINUSMINUS  {: RESULT = new IncreaseDecrease(id, false, idleft, idright); :}
        |ID:id ASSIGNMENT EXPRESION:exp {:  RESULT = new Assignmentt(id, exp, idleft, idright);  :}
        ;

while::= WHILE PAR_OP    EXPRESION:a   PAR_CL K_OP  InstructionES:ins K_CL
                {: RESULT = new CiclicaWhile(a, ins, false,aleft, aright); :}
        ;

do::= DO K_OP  InstructionES:ins K_CL WHILE PAR_OP    EXPRESION:a   PAR_CL SEMIC
                {: RESULT = new CiclicaWhile(a, ins, true, aleft, aright); :}
        ;


match::= SWITCH EXPRESION:exp K_OP  listCases:cazzoz K_CL
                {: RESULT = new Match(exp, cazzoz, expleft, expright); :}
;

listCases::=  listCases:b  case:a {: RESULT = b; RESULT.add(a); :}
        |   {:  RESULT = new LinkedList<>();  :}
        ;


case::= CASE EXPRESION:a POINTS    InstructionES:ins BREAK SEMIC
        {: RESULT = new CaseMatch(a, ins, false, aleft, aright); :}
        | DEFAULT:a  POINTS InstructionES:ins BREAK SEMIC
        {: RESULT = new CaseMatch(null, ins, true, aleft, aright); :}
;




declaraAsigna::= declaracion:w {: RESULT = w; :}
                | asignacion:w	{: RESULT = w; :}
                ;

cierreElse::= ELSE K_OP InstructionES:ins {: RESULT = ins;  :} K_CL 
;

simpleIf::=  IF PAR_OP EXPRESION:a PAR_CL  K_OP instructionsIF:ins K_CL   
                                {: RESULT = new IF(a, ins, aleft, aright); :}
; 

//     public IF(Instruction expression, LinkedList<Instruction> instructionss, LinkedList<Instruction> instructionsElse, int linea, int col) {
elsees::=  IF PAR_OP EXPRESION:exp PAR_CL  K_OP instructionsIF:ins K_CL cierreElse:insEls   
                {: RESULT = new IF(exp, ins, insEls, expleft, expright); :}
;


print::= PRINT PAR_OP paramss:a PAR_CL SEMIC   {:   RESULT = new Prints(a, false, aleft, aright);   :}
        |PRINTLN PAR_OP paramss:a PAR_CL SEMIC   {:   RESULT = new Prints(a, true, aleft, aright);   :}
;

 
declaracion::=   typeVar:t ID:string   SEMIC                     {: RESULT = new Statement(string, t, tleft, tright, false); :}
            |    typeVar:t ID:string   ASSIGNMENT EXPRESION:exp SEMIC  {: RESULT = new Statement(string, exp, t, tleft, tright, false); :}    
            | typeVar:t ID:id ASSIGNMENT INP_INT PAR_OP PAR_CL SEMIC
{:  RESULT = new Statement(id, new Input(new Tipo(tipoDato.ENTERO), idleft, idright), t, idleft, idright, false);  :}
             | typeVar:t ID:id ASSIGNMENT INP_C PAR_OP PAR_CL SEMIC
{:  RESULT = new Statement(id, new Input(new Tipo(tipoDato.CARACTER), idleft, idright), t, idleft, idright, false);  :}
             | typeVar:t ID:id ASSIGNMENT INP_F PAR_OP PAR_CL SEMIC
{:  RESULT = new Statement(id, new Input(new Tipo(tipoDato.DECIMAL), idleft, idright), t, idleft, idright, false);  :}

;




globalDec::=  modPriv  typeVar:t ID:string   SEMIC               
               {: RESULT = new Statement(string, t, tleft, tright, false); :}
            | modPriv  typeVar:t ID:string   ASSIGNMENT EXPRESION:exp SEMIC 
                {: RESULT = new Statement(string, exp, t, tleft, tright, false); :}    
            |    typeVar:t ID:string   SEMIC               
               {: RESULT = new Statement(string, t, tleft, tright, false); :}
            |    typeVar:t ID:string   ASSIGNMENT EXPRESION:exp SEMIC 
                {: RESULT = new Statement(string, exp, t, tleft, tright, false); :}    
     
        ;
        // mutabilidad:a ID:string POINTS typeVar:t SEMIC                     {: RESULT = new Statement(string, t, aleft, aright, a); :}
        //     |     modPriv mutabilidad:a ID:string POINTS typeVar:t ASSIGNMENT EXPRESION:exp SEMIC {: RESULT = new Statement(string, exp, t, aleft, aright, a); :}    
        //     |     modPriv mutabilidad:a ID:string POINTS ID:st ASSIGNMENT K_OP valuesStruct:valuess K_CL SEMIC 
        //         {: RESULT = new InstanceStruct(string, st, a, valuess, stringleft, stringright ); :}
        // ;
//     var p1: persona = { nombre: "Luis", edad: 20, estatura: 1.60 };


//public VectorsStatement(String identificador, boolean isConst, LinkedList<Instruction> valuesVect, LinkedList<LinkedList<Instruction>> valuesVect2D, Tipo tipo, int linea, int col) {

// dimArr::= ID:a      {:   RESULT = new Access(a, aleft, aright);   :}
//         | ENTERO:a      {:   RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright );   :}

// ;

declaracionEstructuraD::= mutabilidad:a ID:id POINTS typeVar:t BRACK_L  EXPRESION:e1 BRACK_R  SEMIC
                         {: RESULT = new VectorsStatement(a, id, e1,  t,  aleft, aright); :}
                         |mutabilidad:a ID:id POINTS typeVar:t BRACK_L EXPRESION:e1 BRACK_R BRACK_L EXPRESION:e2 BRACK_R SEMIC
                         {: RESULT = new VectorsStatement(a, id, e1, e2, t, aleft, aright); :}
        ;

    
// valoresVector2D::= BRACK_L valoresVectorAlone:vals BRACK_R {: RESULT = new LinkedList<>(); RESULT.add(vals); :}
//                 | valoresVector2D:listaVals  COLON BRACK_L valoresVectorAlone:vals BRACK_R {: RESULT = listaVals; RESULT.add(vals); :}    
// ;


// valoresVectorAlone::= EXPRESION:exp {: RESULT = new LinkedList<>();  RESULT.add(exp);  :}   //aqui solo entra la primera o ultima vez
//                     |  valoresVectorAlone:valuess   COLON EXPRESION:exp     {: RESULT = valuess; RESULT.add(exp); :}
// ;

 

assig_to_acces::=ID  PAR_OP paramss PAR_CL DOT assig_to_acces
                | ID DOT assig_to_acces
                | ID
;

//     public Assignmentt(String id, Instruction exp, int linea, int col) {
asignacion::= THIS DOT ID:id ASSIGNMENT EXPRESION:exp SEMIC {:  RESULT = new Assignmentt(true, id, exp, idleft, idright);  :}
             | ID:id ASSIGNMENT EXPRESION:exp SEMIC {:  RESULT = new Assignmentt(id, exp, idleft, idright);  :}
             
             
             | ID DOT assig_to_acces ASSIGNMENT EXPRESION SEMIC
             | ID PAR_OP paramss PAR_CL DOT assig_to_acces ASSIGNMENT EXPRESION SEMIC


             | ID:id BRACK_L EXPRESION:index1 BRACK_R ASSIGNMENT EXPRESION:exp  SEMIC 
                {: RESULT = new AssignmentVectores(id, index1, exp, idleft, idright); :}
             | ID:id BRACK_L EXPRESION:index1 BRACK_R BRACK_L EXPRESION:index2 BRACK_R ASSIGNMENT EXPRESION:exp  SEMIC
              {: RESULT = new AssignmentVectores(id, index1, index2, exp, idleft, idright); :}
             | ID:id ASSIGNMENT INP_INT PAR_OP PAR_CL SEMIC
{:  RESULT = new Assignmentt(id, new Input(new Tipo(tipoDato.ENTERO), idleft, idright), idleft, idright);  :}
             | ID:id ASSIGNMENT INP_C PAR_OP PAR_CL SEMIC
{:  RESULT = new Assignmentt(id, new Input(new Tipo(tipoDato.CARACTER), idleft, idright), idleft, idright);  :}
             | ID:id ASSIGNMENT INP_F PAR_OP PAR_CL SEMIC
{:  RESULT = new Assignmentt(id, new Input(new Tipo(tipoDato.DECIMAL), idleft, idright), idleft, idright);  :}
        ; 

        // numeros[0][0] = 10;
//       vector2[j] = vector2[j + 1];
//       vector1[1] = "World";


increaseDecrease::=  ID:id PLUSPLUS SEMIC {: RESULT = new IncreaseDecrease(id, true, idleft, idright); :}
    |ID:id  MINUSMINUS SEMIC {: RESULT = new IncreaseDecrease(id, false, idleft, idright); :}
    ;


mutabilidad::= VAR {: RESULT = false; :}
        |CONST {: RESULT = true; :}
        ;

typeVar::=STRING        {: RESULT = new Tipo(tipoDato.CADENA); :}
        |INT             {: RESULT = new Tipo(tipoDato.ENTERO); :}
        |DOUBLE         {: RESULT = new Tipo(tipoDato.DECIMAL); :}
        |CHAR            {: RESULT = new Tipo(tipoDato.CARACTER); :}
        |BOOLEAN          {: RESULT = new Tipo(tipoDato.BOOLEANO); :}
        // |VOID          {: RESULT = new Tipo(tipoDato.VOID); :}
        | ID:id             {: RESULT = new Tipo(tipoDato.OBJECT); RESULT.setIdObjeto(id.toString()); :}
        ;


break::= BREAK:w SEMIC {: RESULT = new transferBreak(wleft, wright);    :}
;

continue::= CONTINUE:a SEMIC {: RESULT = new transferContinue(aleft, aright); :}
;
returnn::= RETURN:a SEMIC {: RESULT = new transferReturn(aleft, aright); :}
        |RETURN:a  EXPRESION:exp SEMIC {: RESULT = new transferReturn(exp, expleft, expright); :}
;       

 




 

//#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$
                        // PASCAL
//#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$

// initiate::= PROGRAM ID SEMIC sttmInicialPas:ins {:  RESULT = ins; :}
   
 
//GRAMATICA PROGRAMA PASCAL
pascalCode::= funtionssPas:pas  
        {:  
                Subprog_pascal subp = new Subprog_pascal(pas);
                RESULT = subp; 
        :}
;
          
funtionssPas::= funtionssPas:fs function:fun {: RESULT = fs; RESULT.add(fun); :}
        | function:fun {: RESULT = new LinkedList<>(); RESULT.add(fun); :} 
;     
 
   
InstructionESPas::=  InstructionESPas:inss InstructionPas:ins {: RESULT = inss;  RESULT.add(ins); :} 
                | InstructionPas:ins    {: RESULT = new LinkedList<>(); RESULT.add(ins); :}         
;

 
// {: RESULT = ins; :}   
InstructionPas::= printPas:ins SEMIC    {: RESULT = ins; :}
                | inputPas:ins SEMIC     {: RESULT = ins; :}
                | asignacionPas:ins SEMIC   {: RESULT = ins; :}
                |  ifPas:ins SEMIC {: RESULT = ins; :}      
                | casePas:ins SEMIC {: RESULT = ins; :}
                | forPas:ins {: RESULT = ins; :}
                | whilePas:ins {: RESULT = ins; :}
                | repeatPas:ins {: RESULT = ins; :}
                | breakPas:ins SEMIC {: RESULT = ins; :}
                | continuePas:ins SEMIC {: RESULT = ins; :}
                | AssignmentVectoresPas:ins SEMIC {: RESULT = ins; :}
                // | callPas:ins SEMIC {: RESULT = ins; :}
                | error SEMIC {:  RESULT = null; :} 
                // | error InstructionESPas
                | error 
;

                
 ifPas::=  IF PAR_OP expPas:a PAR_CL THEN insIfNoSemi:ins    
                                 {: RESULT = new IFpas(a, ins, aleft, aright); :}  
                | IF PAR_OP expPas:a PAR_CL THEN insIfNoSemi:ins ELSE insIfNoSemi:ins2
                                 {: RESULT = new IFpas(a, ins, ins2, aleft, aright); :}  
                // | IF PAR_OP expPas:a PAR_CL InstructionPas:ins
                // //                 // {: RESULT = new IFpas(a, ins, aleft, aright); :}  
;
//     public IFpas(InstructionPas expression, LinkedList<InstructionPas> instructionss, LinkedList<InstructionPas> instructionsElse, int linea, int col) {
//     public IFpas(InstructionPas expression, LinkedList<InstructionPas> instructionss,  InstructionPas elif, int linea, int col) {


InstructionSinSemi::=     printPas:ins     {: RESULT = ins; :}
                        |  ifPas:ins   {: RESULT = ins; :}
                        | asignacionPas:ins  {: RESULT = ins; :}
                        | breakPas:ins  {: RESULT = ins; :}
                        | continuePas:ins  {: RESULT = ins; :}
                        | AssignmentVectoresPas:ins  {: RESULT = ins; :}
                        | inputPas:ins {: RESULT = ins; :}
                        // | callPas:ins {: RESULT = ins; :}
                //   | error SEMIC
                //   | error
;
// if_statement ::= IFpas:ifstm expression:exp THEN statement else_statement_optional 
// else_statement_optional ::= | ELSE:elsestm statement:stm


insIfNoSemi::=  BEGIN InstructionESPas:ins END {: RESULT = ins; :}      
         | InstructionSinSemi:ins {: RESULT  = new LinkedList<>(); RESULT.add(ins); :}
;


// {: RESULT = new IFpas(exp, ins, elif, expleft, expright);    :}
// printPas::= PRINTLN PAR_OP expPas:a  PAR_CL   
printPas::= PRINTLN PAR_OP expresionessPas:a  PAR_CL   
                 {:    RESULT = new PrintPass(a, aleft, aright);      :}
;
inputPas::= READLN:r PAR_OP ids:idss  PAR_CL   {: RESULT = new ReadlnPas(idss, rleft, rright); :}
;

expresionessPas::=   expresionessPas:exps COLON expPas:exp   {: RESULT = exps;  RESULT.add(exp); :} 
                | expPas:exp  {: RESULT = new LinkedList<>(); RESULT.add(exp); :}  
; 

//tendra una lista de string
//INTERPRETAR(ciclo que creara los simbolos en base a la cantidad de ids)
declaracionPas::=  declaracionPas:inss unaDeclaracion:ins {: RESULT = inss; RESULT.add(ins); :}
            | unaDeclaracion:ins {:RESULT = new LinkedList<>(); RESULT.add(ins); :}
;

unaDeclaracion::= ids:ids POINTS  typeVarPas:t SEMIC {: RESULT = new StatementPas(ids, t, tleft, tright, false); :}
        |ID:id POINTS typeVarPas:t SEMIC {: LinkedList<String> temp = new LinkedList<>(); temp.add(id);  RESULT = new StatementPas(temp, t, tleft, tright, false); :}
        | ID:id POINTS ARRAY BRACK_L ENTERO:i DOT DOT ENTERO:f BRACK_R OF  typeVarPas:t SEMIC
                {: RESULT = new VectorsStatementPas(id, 
                 new Nativo(Integer.parseInt(i), new Tipo(tipoDato.ENTERO), ileft, fright ),
                  new Nativo(Integer.parseInt(f), new Tipo(tipoDato.ENTERO), ileft, fright ), t, idleft, idright); :}
        | error SEMIC
        | error         
;

//ids es una lista de String 
ids::=  ids:idss COLON ID:id  {: RESULT = idss; RESULT.add(id); :}
        |ID:id   {: RESULT  = new LinkedList<>(); RESULT.add(id); :}
;
 

 
asignacionPas::= ID:id ASSIGNMENT expPas:exp    {:  RESULT = new AssignmenttPas(id, exp, idleft, idright);  :}
;


// executor::= BEGIN:a InstructionESPas:ins END DOT  {: RESULT = new Executor(ins, aleft, aright);  :}
// ;

        
typeVarPas::=STRING        {: RESULT = new Tipo(tipoDato.CADENA); :}
        |INT             {: RESULT = new Tipo(tipoDato.ENTERO); :}
        |REAL         {: RESULT = new Tipo(tipoDato.DECIMAL); :}
        |CHAR            {: RESULT = new Tipo(tipoDato.CARACTER); :}
        |BOOLEAN          {: RESULT = new Tipo(tipoDato.ENTERO); :}
        ;


expPas ::= expPas:a PLUS expPas:b   {:   RESULT = new Suma(a, b, OperadoresAritmeticos.SUMA, aleft, aright);   :} 
            | expPas:a MINUS expPas:b   {:   RESULT = new Resta(a, b, OperadoresAritmeticos.RESTA, aleft, aright);   :}
            | expPas:a DIVIDED expPas:b   {:   RESULT = new Division(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);   :}
            | expPas:a TIMES expPas:b   {:   RESULT = new Multiplicacion(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);   :}
            | expPas:a MOD expPas:b   {:   RESULT = new Modulee(a, b, OperadoresAritmeticos.MODULO, aleft, aright);   :}

            | ENTERO:a      {:   RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright );   :}
            | CADENA:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright );   :}     
            | DECIMAL:a     {:   RESULT = new Nativo(new Double(a), new Tipo(tipoDato.DECIMAL), aleft, aright );   :}
            | CHARAC:a      {:   RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright );   :}
            | ID:a      {:   RESULT = new AccessPas(a, aleft, aright);   :}

            | expPas:a EQUALS:op expPas:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.IGUALA, aleft, aright);   :}
            | expPas:a DIFFERENT:op expPas:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.DIFERENTEQUE, aleft, aright);   :}
            | expPas:a LESS:op expPas:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MENOR, aleft, aright);   :}
            | expPas:a L_EQUALS:op expPas:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MENOR_IGUAL, aleft, aright);   :}
            | expPas:a GREATER:op expPas:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MAYOR, aleft, aright);   :}
            | expPas:a G_EQUALS:op expPas:b   {:   RESULT = new OperateRelacionales(a, b, Relational_LogicalOperations.MAYOR_IGUAL, aleft, aright);   :}
            | PAR_OP expPas:a PAR_CL    {:   RESULT = a;   :}  

            | expPas:a AND:log expPas:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.AND, aleft, aright);   :}
            | expPas:a OR:log expPas:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.OR, aleft, aright);   :}
            | NOT expPas:a  {:   RESULT = new LogicalOperations(a, Relational_LogicalOperations.NOT, aleft, aright);   :}              %prec UNEGATIVE
            
            | expPas:a AND THEN expPas:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.ANDTHEN, aleft, aright);   :}
            | expPas:a OR ELSE expPas:b   {:   RESULT = new LogicalOperations(a, b, Relational_LogicalOperations.ORELSE, aleft, aright);   :}
        //vector access
            | ID:a BRACK_L expPas:indx BRACK_R      {:   RESULT = new AccesVectorPas(a, indx, aleft, aright);   :}
        //     | callPas:c {: RESULT = c; :}           
;


// InstructionPas expression, LinkedList<OneCasePas> cazzos, LinkedList<InstructionPas>  instruccionesElse,int linea, int col) {
casePas::= CASE PAR_OP expPas:a PAR_CL OF
                listCasesPas:cz       ELSE InstructionESPas:ins END 
                {: RESULT = new StatementCasePas(a, cz, ins, aleft, aright ); :}
;
listCasesPas::=  listCasesPas:b  unCase:a  {: RESULT = b; RESULT.add(a); :}
        | unCase:a  {:  RESULT = new LinkedList<>();   RESULT.add(a); :}
        ;
//     public OneCasePas(LinkedList<InstructionPas> expresiones, InstructionPas  instruction, int linea, int col) {
unCase::= expresionessPas:exps POINTS InstructionPas:ins 
{: RESULT = new OneCasePas(exps,ins, expsleft, expsright ); :};

//FOR
//  forPas j:= 5 to 10 do
//  printPas('algo:', j);
//     public CiclicaForPas(String id, InstructionPas initialVal, InstructionPas finalVal, LinkedList<InstructionPas> instrucciones, int linea, int col) {
forPas::= FOR:a ID:id ASSIGNMENT expPas:exp   TO expPas:fVals DO bloqueIns:ins
        {: RESULT = new CiclicaForPas(id, exp, fVals, ins, idleft, idright); :}
;

bloqueIns::= BEGIN InstructionESPas:ins END SEMIC  {: RESULT = ins; :}
        | InstructionPas:ins {:RESULT = new LinkedList<>(); RESULT.add(ins); :}
;
    
whilePas::= WHILE PAR_OP expPas:exp PAR_CL DO bloqueIns:ins           
        {: RESULT = new CiclicaWhilePas(exp, ins, false, expleft, expright); :};

repeatPas::= REPEAT InstructionESPas:ins UNTIL PAR_OP  expPas:exp PAR_CL SEMIC
        {: RESULT = new CiclicaWhilePas(exp, ins, true, expleft, expright); :};
breakPas::= BREAK:w  {: RESULT = new transferBreakPas(wleft, wright);    :};
continuePas::= CONTINUE:a  {: RESULT = new transferContinuePas(aleft, aright); :};


//     (String identificador, InstructionPas indI, InstructionPas indF, Tipo tipo, int linea, int col) 
declaraArr::= ID:id POINTS ARRAY BRACK_L expPas:i DOT DOT expPas:f BRACK_R OF  typeVarPas:t SEMIC
        {: RESULT = new VectorsStatementPas(id, i, f, t, idleft, idright); :}
;

//     public AssignmentVectoresPas(String identificator1, InstructionPas index1, InstructionPas exp, int linea, int col) {
AssignmentVectoresPas::= ID:id BRACK_L expPas:exp BRACK_R ASSIGNMENT expPas:val
                {: RESULT = new AssignmentVectoresPas(id, exp, val, idleft, idright); :}
;
 
                                //FUNCTION
function::= FUNCTION ID:id PAR_OP parametersFunctsPas:params PAR_CL POINTS typeVarPas:t SEMIC optionalLocalDc:vars bodyFunction:ins
                {: RESULT = new FunctionssPas(id, params, ins, vars, t, idleft, idright ); :}
         | FUNCTION ID:id PAR_OP PAR_CL POINTS typeVarPas:t SEMIC optionalLocalDc:vars  bodyFunction:ins
                {: RESULT = new FunctionssPas(id, new LinkedList<>(), ins,  vars, t, idleft, idright ); :}

        | PROCEDURE ID:id PAR_OP parametersFunctsPas:params PAR_CL  SEMIC optionalLocalDc:vars bodyFunction:ins
                {: RESULT = new MethodPas(id, params, ins, vars, new Tipo(tipoDato.VOID), idleft, idright ); :}
        |  PROCEDURE ID:id PAR_OP PAR_CL   SEMIC optionalLocalDc:vars  bodyFunction:ins
                {: RESULT = new MethodPas(id, new LinkedList<>(), ins,  vars, new Tipo(tipoDato.VOID), idleft, idright ); :}
;

 

optionalLocalDc::= variablesFunct:vars {:RESULT = vars; :}
        | {:RESULT = new LinkedList<>(); :}
;
 
variablesFunct::= VAR declaracionPas:vars  {: RESULT = vars; :}
;
bodyFunction::= BEGIN InstructionESPas:ins END SEMIC {: RESULT = ins; :}
;
//(var1, var2: integer; uno, dos: string)
parametersFunctsPas ::= parametersFunctsPas:params SEMIC paramFunction:param {:  RESULT = params; RESULT.addAll(param); :}
                |  paramFunction:param {: RESULT = new LinkedList<HashMap>(); RESULT.addAll(param); :}
;

paramFunction::= ids:ids POINTS  typeVarPas:ty {: RESULT = new  LinkedList<HashMap>();
                for (String unIDDD : ids) {
                   var oneParam = new HashMap<String, Object>();
                   oneParam.put("id",unIDDD);
                   oneParam.put("tipo", ty);
                   RESULT.add(oneParam);
                    
                } :}
                 | ID:id POINTS typeVarPas:ty {: RESULT = new LinkedList<HashMap>();
                                         var oneParam = new HashMap<String, Object>();
                                            oneParam.put("id",id);
                                            oneParam.put("tipo", ty);
                                            RESULT.add(oneParam);    :}
 ;


                //llamada a funciones
// callPas::=  ID:a PAR_OP callsParametersPasPas:params PAR_CL {: RESULT =  new Call(a, params , aleft, aright); :} 
//         | ID:a PAR_OP PAR_CL {: RESULT =  new Call(a, new LinkedList<>(), aleft, aright); :} 
// ;

// callsParametersPasPas::= callsParametersPasPas:calls COLON expPas:exp {:  RESULT = calls;  RESULT.add(exp);  :}
//                 | expPas:exp {:  RESULT = new LinkedList<Instruction>();  RESULT.add(exp);   :}
// ;

 